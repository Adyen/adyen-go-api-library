{{>partial_header}}
{{#lambda.lowercase}}
package {{packageName}}
{{/lambda.lowercase}}

{{#operations}}
import (
	_context "context"
	_ioutil "io/ioutil"
	_nethttp "net/http"
	_neturl "net/url"

	common "github.com/adyen/adyen-go-api-library/src/common"
)

// {{packageName}} {{packageName}} service
type {{packageName}} common.Service
{{#operation}}

/*
{{operationId}}{{#summary}} {{{.}}}{{/summary}}{{^summary}} Method for {{operationId}}{{/summary}}
{{#notes}}
{{notes}}
{{/notes}}
{{#allParams}}
{{#required}}
 * @param {{paramName}}{{#description}} {{{.}}}{{/description}}
{{/required}}
{{/allParams}}
{{#hasOptionalParams}}
{{#allParams}}
{{^required}}
 * @param request {{vendorExtensions.x-export-param-name}} - reference of {{dataType}}). {{#description}} {{{.}}}{{/description}}
{{/required}}
{{/allParams}}
{{/hasOptionalParams}}
 * @param ctxs ..._context.Context - optional, for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
{{#returnType}}
@return {{{returnType}}}
{{/returnType}}
*/

func (a *{{{packageName}}}) {{{nickname}}}({{#allParams}}request *{{{dataType}}}{{/allParams}}, ctxs ..._context.Context) ({{#returnType}}{{{returnType}}}, {{/returnType}}*_nethttp.Response, error) {
	var (
		localVarHTTPMethod  = _nethttp.Method{{httpMethod}}
		localVarPostBody    interface{}
		{{#returnType}}
		localVarReturnValue {{{returnType}}}
		{{/returnType}}
	)

	// create path and map variables
	localVarPath := a.BasePath() + "{{{path}}}"{{#pathParams}}
	localVarPath = strings.Replace(localVarPath, "{"+"{{baseName}}"+"}", _neturl.QueryEscape(parameterToString({{paramName}}, "{{#collectionFormat}}{{collectionFormat}}{{/collectionFormat}}")) , -1)
	{{/pathParams}}

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	{{#allParams}}
	{{#required}}
	{{#minItems}}
	if len({{paramName}}) < {{minItems}} {
		return {{#returnType}}localVarReturnValue, {{/returnType}}nil, reportError("{{paramName}} must have at least {{minItems}} elements")
	}
	{{/minItems}}
	{{#maxItems}}
	if len({{paramName}}) > {{maxItems}} {
		return {{#returnType}}localVarReturnValue, {{/returnType}}nil, reportError("{{paramName}} must have less than {{maxItems}} elements")
	}
	{{/maxItems}}
	{{#minLength}}
	if strlen({{paramName}}) < {{minLength}} {
		return {{#returnType}}localVarReturnValue, {{/returnType}}nil, reportError("{{paramName}} must have at least {{minLength}} elements")
	}
	{{/minLength}}
	{{#maxLength}}
	if strlen({{paramName}}) > {{maxLength}} {
		return {{#returnType}}localVarReturnValue, {{/returnType}}nil, reportError("{{paramName}} must have less than {{maxLength}} elements")
	}
	{{/maxLength}}
	{{#minimum}}
	{{#isString}}
	{{paramName}}Txt, err := atoi({{paramName}})
	if {{paramName}}Txt < {{minimum}} {
	{{/isString}}
	{{^isString}}
	if {{paramName}} < {{minimum}} {
	{{/isString}}
		return {{#returnType}}localVarReturnValue, {{/returnType}}nil, reportError("{{paramName}} must be greater than {{minimum}}")
	}
	{{/minimum}}
	{{#maximum}}
	{{#isString}}
	{{paramName}}Txt, err := atoi({{paramName}})
	if {{paramName}}Txt > {{maximum}} {
	{{/isString}}
	{{^isString}}
	if {{paramName}} > {{maximum}} {
	{{/isString}}
		return {{#returnType}}localVarReturnValue, {{/returnType}}nil, reportError("{{paramName}} must be less than {{maximum}}")
	}
	{{/maximum}}
	{{/required}}
	{{/allParams}}

	{{#hasQueryParams}}
	{{#queryParams}}
	{{#required}}
	{{#isCollectionFormatMulti}}
	{
		t:={{paramName}}
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("{{baseName}}", parameterToString(s.Index(i), "{{#collectionFormat}}{{collectionFormat}}{{/collectionFormat}}"))
			}
		} else {
			localVarQueryParams.Add("{{baseName}}", parameterToString(t, "{{#collectionFormat}}{{collectionFormat}}{{/collectionFormat}}"))
		}
	}
	{{/isCollectionFormatMulti}}
	{{^isCollectionFormatMulti}}
	localVarQueryParams.Add("{{baseName}}", parameterToString({{paramName}}, "{{#collectionFormat}}{{collectionFormat}}{{/collectionFormat}}"))
	{{/isCollectionFormatMulti}}
	{{/required}}
	{{^required}}
	if request != nil && request.{{vendorExtensions.x-export-param-name}}.IsSet() {
	{{#isCollectionFormatMulti}}
		t:=request.{{vendorExtensions.x-export-param-name}}.Value()
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("{{baseName}}", parameterToString(s.Index(i), "{{#collectionFormat}}{{collectionFormat}}{{/collectionFormat}}"))
			}
		} else {
			localVarQueryParams.Add("{{baseName}}", parameterToString(t, "{{#collectionFormat}}{{collectionFormat}}{{/collectionFormat}}"))
		}
	{{/isCollectionFormatMulti}}
	{{^isCollectionFormatMulti}}
		localVarQueryParams.Add("{{baseName}}", parameterToString(request.{{vendorExtensions.x-export-param-name}}.Value(), "{{#collectionFormat}}{{collectionFormat}}{{/collectionFormat}}"))
	{{/isCollectionFormatMulti}}
	}
	{{/required}}
	{{/queryParams}}
	{{/hasQueryParams}}
	// to determine the Content-Type header
{{=<% %>=}}
	localVarHTTPContentTypes := []string{<%#consumes%>"<%&mediaType%>"<%^-last%>, <%/-last%><%/consumes%>}
<%={{ }}=%>

	// set Content-Type header
	localVarHTTPContentType := common.SelectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
{{=<% %>=}}
	localVarHTTPHeaderAccepts := []string{<%#produces%>"<%&mediaType%>"<%^-last%>, <%/-last%><%/produces%>}
<%={{ }}=%>

	// set Accept header
	localVarHTTPHeaderAccept := common.SelectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
{{#hasHeaderParams}}
{{#headerParams}}
	{{#required}}
	localVarHeaderParams["{{baseName}}"] = parameterToString({{paramName}}, "{{#collectionFormat}}{{collectionFormat}}{{/collectionFormat}}")
	{{/required}}
	{{^required}}
	if request != nil && request.{{vendorExtensions.x-export-param-name}}.IsSet() {
		localVarHeaderParams["{{baseName}}"] = parameterToString(request.{{vendorExtensions.x-export-param-name}}.Value(), "{{#collectionFormat}}{{collectionFormat}}{{/collectionFormat}}")
	}
	{{/required}}
{{/headerParams}}
{{/hasHeaderParams}}
{{#hasFormParams}}
{{#formParams}}
{{#isFile}}
	localVarFormFileName = "{{baseName}}"
{{#required}}
	localVarFile := {{paramName}}
{{/required}}
{{^required}}
	var localVarFile {{dataType}}
	if request != nil && request.{{vendorExtensions.x-export-param-name}}.IsSet() {
		localVarFileOk := false
		localVarFile, localVarFileOk = request.{{vendorExtensions.x-export-param-name}}.Value().({{dataType}})
		if !localVarFileOk {
				return {{#returnType}}localVarReturnValue, {{/returnType}}nil, reportError("{{paramName}} should be {{dataType}}")
		}
	}
{{/required}}
	if localVarFile != nil {
		fbs, _ := _ioutil.ReadAll(localVarFile)
		localVarFileBytes = fbs
		localVarFileName = localVarFile.Name()
		localVarFile.Close()
	}
{{/isFile}}
{{^isFile}}
{{#required}}
	localVarFormParams.Add("{{baseName}}", parameterToString({{paramName}}, "{{#collectionFormat}}{{collectionFormat}}{{/collectionFormat}}"))
{{/required}}
{{^required}}
{{#isModel}}
	if request != nil && request.{{vendorExtensions.x-export-param-name}}.IsSet() {
		paramJson, err := parameterToJson(request.{{vendorExtensions.x-export-param-name}}.Value())
		if err != nil {
			return {{#returnType}}localVarReturnValue, {{/returnType}}nil, err
		}
		localVarFormParams.Add("{{baseName}}", paramJson)
	}
{{/isModel}}
{{^isModel}}
	if request != nil && request.{{vendorExtensions.x-export-param-name}}.IsSet() {
		localVarFormParams.Add("{{baseName}}", parameterToString(request.{{vendorExtensions.x-export-param-name}}.Value(), "{{#collectionFormat}}{{collectionFormat}}{{/collectionFormat}}"))
	}
{{/isModel}}
{{/required}}
{{/isFile}}
{{/formParams}}
{{/hasFormParams}}
{{#hasBodyParam}}
{{#bodyParams}}
	// body params
{{#required}}
	localVarPostBody = &{{paramName}}
{{/required}}
{{^required}}
	if request != nil {
		localVarPostBody = request
	}

{{/required}}
{{/bodyParams}}
{{/hasBodyParam}}
{{#authMethods}}
{{#isApiKey}}
{{^isKeyInCookie}}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			{{#isKeyInHeader}}
			localVarHeaderParams["{{keyParamName}}"] = key
			{{/isKeyInHeader}}
			{{#isKeyInQuery}}
			localVarQueryParams.Add("{{keyParamName}}", key)
			{{/isKeyInQuery}}
		}
	}
{{/isKeyInCookie}}
{{/isApiKey}}
{{/authMethods}}
	var ctx _context.Context
	if len(ctxs) == 1 {
		ctx = ctxs[0]
	}

	r, err := a.Client.PrepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams)
	if err != nil {
		return {{#returnType}}localVarReturnValue, {{/returnType}}nil, err
	}

	localVarHTTPResponse, err := a.Client.CallAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return {{#returnType}}localVarReturnValue, {{/returnType}}localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return {{#returnType}}localVarReturnValue, {{/returnType}}localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := common.NewApiError(localVarBody, localVarHTTPResponse.Status)
		return {{#returnType}}localVarReturnValue, {{/returnType}}localVarHTTPResponse, newErr
	}

	{{#returnType}}
	err = a.Client.Decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := common.NewApiError(localVarBody, err.Error())
		return {{#returnType}}localVarReturnValue, {{/returnType}}localVarHTTPResponse, newErr
	}

	{{/returnType}}
	return {{#returnType}}localVarReturnValue, {{/returnType}}localVarHTTPResponse, nil
}
{{/operation}}
{{/operations}}
