/*
Adyen Checkout API

Adyen Checkout API provides a simple and flexible way to initiate and authorise online payments. You can use the same integration for payments made with cards (including 3D Secure), mobile wallets, and local payment methods (for example, iDEAL and Sofort).  This API reference provides information on available endpoints and how to interact with them. To learn more about the API, visit [online payments documentation](https://docs.adyen.com/online-payments).  ## Authentication Each request to Checkout API must be signed with an API key. For this, [get your API key](https://docs.adyen.com/development-resources/api-credentials#generate-api-key) from your Customer Area, and set this key to the `X-API-Key` header value, for example:  ``` curl -H \"Content-Type: application/json\" \\ -H \"X-API-Key: YOUR_API_KEY\" \\ ... ``` ## Versioning Checkout API supports [versioning](https://docs.adyen.com/development-resources/versioning) using a version suffix in the endpoint URL. This suffix has the following format: \"vXX\", where XX is the version number.  For example: ``` https://checkout-test.adyen.com/v70/payments ```  ## Going live  To access the live endpoints, you need an API key from your live Customer Area.  The live endpoint URLs contain a prefix which is unique to your company account, for example: ``` https://{PREFIX}-checkout-live.adyenpayments.com/checkout/v70/payments ```  Get your `{PREFIX}` from your live Customer Area under **Developers** > **API URLs** > **Prefix**.  When preparing to do live transactions with Checkout API, follow the [go-live checklist](https://docs.adyen.com/online-payments/go-live-checklist) to make sure you've got all the required configuration in place.  ## Release notes Have a look at the [release notes](https://docs.adyen.com/online-payments/release-notes?integration_type=api&version=70) to find out what changed in this version!

API version: 70
Contact: developer-experience@adyen.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package checkout

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)

// RecurringApiService RecurringApi service
type RecurringApiService service

type ApiDeleteStoredPaymentMethodsRecurringIdRequest struct {
	ctx              context.Context
	ApiService       *RecurringApiService
	recurringId      string
	shopperReference *string
	merchantAccount  *string
}

// Your reference to uniquely identify this shopper, for example user ID or account ID. Minimum length: 3 characters. &gt; Your reference must not include personally identifiable information (PII), for example name or email address.
func (r ApiDeleteStoredPaymentMethodsRecurringIdRequest) ShopperReference(shopperReference string) ApiDeleteStoredPaymentMethodsRecurringIdRequest {
	r.shopperReference = &shopperReference
	return r
}

// Your merchant account.
func (r ApiDeleteStoredPaymentMethodsRecurringIdRequest) MerchantAccount(merchantAccount string) ApiDeleteStoredPaymentMethodsRecurringIdRequest {
	r.merchantAccount = &merchantAccount
	return r
}

func (r ApiDeleteStoredPaymentMethodsRecurringIdRequest) Execute() (*StoredPaymentMethodResource, *http.Response, error) {
	return r.ApiService.DeleteStoredPaymentMethodsRecurringIdExecute(r)
}

/*
DeleteStoredPaymentMethodsRecurringId Delete a token for stored payment details

Deletes the token identified in the path. The token can no longer be used with payment requests.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param recurringId The unique identifier of the token.
 @return ApiDeleteStoredPaymentMethodsRecurringIdRequest
*/
func (a *RecurringApiService) DeleteTokenForStoredPaymentDetails(ctx context.Context, recurringId string) ApiDeleteStoredPaymentMethodsRecurringIdRequest {
	return ApiDeleteStoredPaymentMethodsRecurringIdRequest{
		ApiService:  a,
		ctx:         ctx,
		recurringId: recurringId,
	}
}

// Execute executes the request
//  @return StoredPaymentMethodResource
func (a *RecurringApiService) DeleteStoredPaymentMethodsRecurringIdExecute(r ApiDeleteStoredPaymentMethodsRecurringIdRequest) (*StoredPaymentMethodResource, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodDelete
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *StoredPaymentMethodResource
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RecurringApiService.DeleteStoredPaymentMethodsRecurringId")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/storedPaymentMethods/{recurringId}"
	localVarPath = strings.Replace(localVarPath, "{"+"recurringId"+"}", url.PathEscape(parameterValueToString(r.recurringId, "recurringId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.shopperReference != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "shopperReference", r.shopperReference, "")
	}
	if r.merchantAccount != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "merchantAccount", r.merchantAccount, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// attempt to fetch API key from configuration first
	if a.client.cfg.ApiKey != "" {
		localVarHeaderParams["X-API-Key"] = a.client.cfg.ApiKey
	}

	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetStoredPaymentMethodsRequest struct {
	ctx              context.Context
	ApiService       *RecurringApiService
	shopperReference *string
	merchantAccount  *string
}

// Your reference to uniquely identify this shopper, for example user ID or account ID. Minimum length: 3 characters. &gt; Your reference must not include personally identifiable information (PII), for example name or email address.
func (r ApiGetStoredPaymentMethodsRequest) ShopperReference(shopperReference string) ApiGetStoredPaymentMethodsRequest {
	r.shopperReference = &shopperReference
	return r
}

// Your merchant account.
func (r ApiGetStoredPaymentMethodsRequest) MerchantAccount(merchantAccount string) ApiGetStoredPaymentMethodsRequest {
	r.merchantAccount = &merchantAccount
	return r
}

func (r ApiGetStoredPaymentMethodsRequest) Execute() (*ListStoredPaymentMethodsResponse, *http.Response, error) {
	return r.ApiService.GetStoredPaymentMethodsExecute(r)
}

/*
GetStoredPaymentMethods Get tokens for stored payment details

Lists the tokens for stored payment details for the shopper identified in the path, if there are any available. The token ID can be used with payment requests for the shopper's payment. A summary of the stored details is included.



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetStoredPaymentMethodsRequest
*/
func (a *RecurringApiService) GetTokensForStoredPaymentDetails(ctx context.Context) ApiGetStoredPaymentMethodsRequest {
	return ApiGetStoredPaymentMethodsRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return ListStoredPaymentMethodsResponse
func (a *RecurringApiService) GetStoredPaymentMethodsExecute(r ApiGetStoredPaymentMethodsRequest) (*ListStoredPaymentMethodsResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ListStoredPaymentMethodsResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RecurringApiService.GetStoredPaymentMethods")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/storedPaymentMethods"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.shopperReference != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "shopperReference", r.shopperReference, "")
	}
	if r.merchantAccount != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "merchantAccount", r.merchantAccount, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// attempt to fetch API key from configuration first
	if a.client.cfg.ApiKey != "" {
		localVarHeaderParams["X-API-Key"] = a.client.cfg.ApiKey
	}

	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
