/*
Management API

Configure and manage your Adyen company and merchant accounts, stores, and payment terminals. ## Authentication Each request to the Management API must be signed with an API key. [Generate your API key](https://docs.adyen.com/development-resources/api-credentials#generate-api-key) in the Customer Area and then set this key to the `X-API-Key` header value.  To access the live endpoints, you need to generate a new API key in your live Customer Area. ## Versioning  Management API handles versioning as part of the endpoint URL. For example, to send a request to version 1 of the `/companies/{companyId}/webhooks` endpoint, use:  ```text https://management-test.adyen.com/v1/companies/{companyId}/webhooks ```

API version: 1
Contact: developer-experience@adyen.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package Management

import (
	"bytes"
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
)


// TerminalsTerminalLevelApiService TerminalsTerminalLevelApi service
type TerminalsTerminalLevelApiService service

type ApiGetTerminalsRequest struct {
	ctx context.Context
	ApiService *TerminalsTerminalLevelApiService
	searchQuery *string
	countries *string
	merchantIds *string
	storeIds *string
	brandModels *string
	pageNumber *int32
	pageSize *int32
}

// Returns terminals with an ID that contains the specified string. If present, other query parameters are ignored.
func (r ApiGetTerminalsRequest) SearchQuery(searchQuery string) ApiGetTerminalsRequest {
	r.searchQuery = &searchQuery
	return r
}

// Returns terminals located in the countries specified by their [two-letter country code](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2).
func (r ApiGetTerminalsRequest) Countries(countries string) ApiGetTerminalsRequest {
	r.countries = &countries
	return r
}

// Returns terminals that belong to the merchant accounts specified by their unique merchant account ID.
func (r ApiGetTerminalsRequest) MerchantIds(merchantIds string) ApiGetTerminalsRequest {
	r.merchantIds = &merchantIds
	return r
}

// Returns terminals that are assigned to the [stores](https://docs.adyen.com/api-explorer/#/ManagementService/latest/get/stores) specified by their unique store ID.
func (r ApiGetTerminalsRequest) StoreIds(storeIds string) ApiGetTerminalsRequest {
	r.storeIds = &storeIds
	return r
}

// Returns terminals of the [models](https://docs.adyen.com/api-explorer/#/ManagementService/latest/get/companies/{companyId}/terminalModels) specified in the format *brand.model*.
func (r ApiGetTerminalsRequest) BrandModels(brandModels string) ApiGetTerminalsRequest {
	r.brandModels = &brandModels
	return r
}

// The number of the page to fetch.
func (r ApiGetTerminalsRequest) PageNumber(pageNumber int32) ApiGetTerminalsRequest {
	r.pageNumber = &pageNumber
	return r
}

// The number of items to have on a page, maximum 100. The default is 20 items on a page.
func (r ApiGetTerminalsRequest) PageSize(pageSize int32) ApiGetTerminalsRequest {
	r.pageSize = &pageSize
	return r
}

func (r ApiGetTerminalsRequest) Execute() (*ListTerminalsResponse, *http.Response, error) {
	return r.ApiService.GetTerminalsExecute(r)
}

/*
GetTerminals Get a list of terminals

Returns the payment terminals that the API credential has access to and that match the query parameters. 
When using `searchQuery`, other query parameters are ignored.

To make this request, your API credential must have one of the following [roles](https://docs.adyen.com/development-resources/api-credentials#api-permissions):
* Management API—Terminal actions read
* Management API—Terminal actions read and write

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetTerminalsRequest
*/
func (a *TerminalsTerminalLevelApiService) GetTerminals(ctx context.Context) ApiGetTerminalsRequest {
	// add APIKey to Context
	ctxWithApiKey := context.WithValue(context.Background(), ContextAPIKeys, 
	map[string]APIKey {
		"ApiKeyAuth" : {Key: a.client.cfg.ApiKey},
	})
	
	return ApiGetTerminalsRequest{
		ApiService: a,
		ctx: ctxWithApiKey,
	}
}

// Execute executes the request
//  @return ListTerminalsResponse
func (a *TerminalsTerminalLevelApiService) GetTerminalsExecute(r ApiGetTerminalsRequest) (*ListTerminalsResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListTerminalsResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TerminalsTerminalLevelApiService.GetTerminals")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/terminals"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.searchQuery != nil {
		localVarQueryParams.Add("searchQuery", parameterToString(*r.searchQuery, ""))
	}
	if r.countries != nil {
		localVarQueryParams.Add("countries", parameterToString(*r.countries, ""))
	}
	if r.merchantIds != nil {
		localVarQueryParams.Add("merchantIds", parameterToString(*r.merchantIds, ""))
	}
	if r.storeIds != nil {
		localVarQueryParams.Add("storeIds", parameterToString(*r.storeIds, ""))
	}
	if r.brandModels != nil {
		localVarQueryParams.Add("brandModels", parameterToString(*r.brandModels, ""))
	}
	if r.pageNumber != nil {
		localVarQueryParams.Add("pageNumber", parameterToString(*r.pageNumber, ""))
	}
	if r.pageSize != nil {
		localVarQueryParams.Add("pageSize", parameterToString(*r.pageSize, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v RestServiceError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v RestServiceError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v RestServiceError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v RestServiceError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v RestServiceError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
