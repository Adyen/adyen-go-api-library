/*
Configuration API

API version: 2
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package balanceplatform

import (
	"context"
    "net/http"
    "net/url"
    "strings"
    "github.com/adyen/adyen-go-api-library/v21/src/common"
)

// TransferLimitsBalancePlatformLevelApi service
type TransferLimitsBalancePlatformLevelApi common.Service

// All parameters accepted by TransferLimitsBalancePlatformLevelApi.CreateTransferLimit
type TransferLimitsBalancePlatformLevelApiCreateTransferLimitInput struct {
	id string
	createTransferLimitRequest *CreateTransferLimitRequest
}

func (r TransferLimitsBalancePlatformLevelApiCreateTransferLimitInput) CreateTransferLimitRequest(createTransferLimitRequest CreateTransferLimitRequest) TransferLimitsBalancePlatformLevelApiCreateTransferLimitInput {
	r.createTransferLimitRequest = &createTransferLimitRequest
	return r
}


/*
Prepare a request for CreateTransferLimit
@param id The unique identifier of the balance platform.
@return TransferLimitsBalancePlatformLevelApiCreateTransferLimitInput
*/
func (a *TransferLimitsBalancePlatformLevelApi) CreateTransferLimitInput(id string) TransferLimitsBalancePlatformLevelApiCreateTransferLimitInput {
	return TransferLimitsBalancePlatformLevelApiCreateTransferLimitInput{
		id: id,
	}
}

/*
CreateTransferLimit Create a transfer limit

Create a transfer limit for your balance platform using the unique `id` of your balance platform.


@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
@param r TransferLimitsBalancePlatformLevelApiCreateTransferLimitInput - Request parameters, see CreateTransferLimitInput
@return TransferLimit, *http.Response, error
*/
func (a *TransferLimitsBalancePlatformLevelApi) CreateTransferLimit(ctx context.Context, r TransferLimitsBalancePlatformLevelApiCreateTransferLimitInput) (TransferLimit, *http.Response, error) {
    res := &TransferLimit{}
	path := "/balancePlatforms/{id}/transferLimits"
    path = strings.Replace(path, "{"+"id"+"}", url.PathEscape(common.ParameterValueToString(r.id, "id")), -1)
    queryParams := url.Values{}
    headerParams := make(map[string]string)
    httpRes, err := common.SendAPIRequest(
        ctx,
        a.Client,
        r.createTransferLimitRequest,
        res,
        http.MethodPost,
        a.BasePath()+path,
        queryParams,
        headerParams,
    )

    if httpRes == nil {
        return *res, httpRes, err
    }

    var serviceError common.RestServiceError
                        if httpRes.StatusCode == 404 {
                            body, _ := ioutil.ReadAll(httpRes.Body)
                            decodeError := json.Unmarshal([]byte(body), &serviceError)
                            if decodeError != nil {
                                return *res, httpRes, decodeError
                            }
                            return *res, httpRes, serviceError
                        }
                        if httpRes.StatusCode == 422 {
                            body, _ := ioutil.ReadAll(httpRes.Body)
                            decodeError := json.Unmarshal([]byte(body), &serviceError)
                            if decodeError != nil {
                                return *res, httpRes, decodeError
                            }
                            return *res, httpRes, serviceError
                        }

    return *res, httpRes, err
}


// All parameters accepted by TransferLimitsBalancePlatformLevelApi.DeletePendingTransferLimit
type TransferLimitsBalancePlatformLevelApiDeletePendingTransferLimitInput struct {
	id string
	transferLimitId string
}


/*
Prepare a request for DeletePendingTransferLimit
@param id The unique identifier of the balance platform.@param transferLimitId The unique identifier of the transfer limit.
@return TransferLimitsBalancePlatformLevelApiDeletePendingTransferLimitInput
*/
func (a *TransferLimitsBalancePlatformLevelApi) DeletePendingTransferLimitInput(id string, transferLimitId string) TransferLimitsBalancePlatformLevelApiDeletePendingTransferLimitInput {
	return TransferLimitsBalancePlatformLevelApiDeletePendingTransferLimitInput{
		id: id,
		transferLimitId: transferLimitId,
	}
}

/*
DeletePendingTransferLimit Delete a scheduled or pending transfer limit

Delete a scheduled or pending transfer limit using its unique `transferLimitId`. You cannot delete an active limit.


@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
@param r TransferLimitsBalancePlatformLevelApiDeletePendingTransferLimitInput - Request parameters, see DeletePendingTransferLimitInput
@return *http.Response, error
*/
func (a *TransferLimitsBalancePlatformLevelApi) DeletePendingTransferLimit(ctx context.Context, r TransferLimitsBalancePlatformLevelApiDeletePendingTransferLimitInput) (*http.Response, error) {
    var res interface{}
	path := "/balancePlatforms/{id}/transferLimits/{transferLimitId}"
    path = strings.Replace(path, "{"+"id"+"}", url.PathEscape(common.ParameterValueToString(r.id, "id")), -1)
    path = strings.Replace(path, "{"+"transferLimitId"+"}", url.PathEscape(common.ParameterValueToString(r.transferLimitId, "transferLimitId")), -1)
    queryParams := url.Values{}
    headerParams := make(map[string]string)
    httpRes, err := common.SendAPIRequest(
        ctx,
        a.Client,
        nil,
        res,
        http.MethodDelete,
        a.BasePath()+path,
        queryParams,
        headerParams,
    )

    if httpRes == nil {
        return httpRes, err
    }

    var serviceError common.RestServiceError
                        if httpRes.StatusCode == 404 {
                            body, _ := ioutil.ReadAll(httpRes.Body)
                            decodeError := json.Unmarshal([]byte(body), &serviceError)
                            if decodeError != nil {
                                return httpRes, decodeError
                            }
                            return httpRes, serviceError
                        }
                        if httpRes.StatusCode == 422 {
                            body, _ := ioutil.ReadAll(httpRes.Body)
                            decodeError := json.Unmarshal([]byte(body), &serviceError)
                            if decodeError != nil {
                                return httpRes, decodeError
                            }
                            return httpRes, serviceError
                        }

    return httpRes, err
}


// All parameters accepted by TransferLimitsBalancePlatformLevelApi.GetSpecificTransferLimit
type TransferLimitsBalancePlatformLevelApiGetSpecificTransferLimitInput struct {
	id string
	transferLimitId string
}


/*
Prepare a request for GetSpecificTransferLimit
@param id The unique identifier of the balance platform.@param transferLimitId The unique identifier of the transfer limit.
@return TransferLimitsBalancePlatformLevelApiGetSpecificTransferLimitInput
*/
func (a *TransferLimitsBalancePlatformLevelApi) GetSpecificTransferLimitInput(id string, transferLimitId string) TransferLimitsBalancePlatformLevelApiGetSpecificTransferLimitInput {
	return TransferLimitsBalancePlatformLevelApiGetSpecificTransferLimitInput{
		id: id,
		transferLimitId: transferLimitId,
	}
}

/*
GetSpecificTransferLimit Get the details of a transfer limit

Get the details of a transfer limit using its unique `transferLimitId`.


@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
@param r TransferLimitsBalancePlatformLevelApiGetSpecificTransferLimitInput - Request parameters, see GetSpecificTransferLimitInput
@return TransferLimit, *http.Response, error
*/
func (a *TransferLimitsBalancePlatformLevelApi) GetSpecificTransferLimit(ctx context.Context, r TransferLimitsBalancePlatformLevelApiGetSpecificTransferLimitInput) (TransferLimit, *http.Response, error) {
    res := &TransferLimit{}
	path := "/balancePlatforms/{id}/transferLimits/{transferLimitId}"
    path = strings.Replace(path, "{"+"id"+"}", url.PathEscape(common.ParameterValueToString(r.id, "id")), -1)
    path = strings.Replace(path, "{"+"transferLimitId"+"}", url.PathEscape(common.ParameterValueToString(r.transferLimitId, "transferLimitId")), -1)
    queryParams := url.Values{}
    headerParams := make(map[string]string)
    httpRes, err := common.SendAPIRequest(
        ctx,
        a.Client,
        nil,
        res,
        http.MethodGet,
        a.BasePath()+path,
        queryParams,
        headerParams,
    )

    if httpRes == nil {
        return *res, httpRes, err
    }

    var serviceError common.RestServiceError
                        if httpRes.StatusCode == 404 {
                            body, _ := ioutil.ReadAll(httpRes.Body)
                            decodeError := json.Unmarshal([]byte(body), &serviceError)
                            if decodeError != nil {
                                return *res, httpRes, decodeError
                            }
                            return *res, httpRes, serviceError
                        }
                        if httpRes.StatusCode == 422 {
                            body, _ := ioutil.ReadAll(httpRes.Body)
                            decodeError := json.Unmarshal([]byte(body), &serviceError)
                            if decodeError != nil {
                                return *res, httpRes, decodeError
                            }
                            return *res, httpRes, serviceError
                        }

    return *res, httpRes, err
}


// All parameters accepted by TransferLimitsBalancePlatformLevelApi.GetTransferLimits
type TransferLimitsBalancePlatformLevelApiGetTransferLimitsInput struct {
	id string
	scope *Scope
	transferType *TransferType
	status *LimitStatus
}

// The scope to which the transfer limit applies. Possible values: * **perTransaction**: you set a maximum amount for each transfer made from the balance account or balance platform. * **perDay**: you set a maximum total amount for all transfers made from the balance account or balance platform in a day.
func (r TransferLimitsBalancePlatformLevelApiGetTransferLimitsInput) Scope(scope Scope) TransferLimitsBalancePlatformLevelApiGetTransferLimitsInput {
	r.scope = &scope
	return r
}

// The type of transfer to which the limit applies. Possible values: * **instant**: the limit applies to transfers with an **instant** priority. * **all**: the limit applies to all transfers, regardless of priority.
func (r TransferLimitsBalancePlatformLevelApiGetTransferLimitsInput) TransferType(transferType TransferType) TransferLimitsBalancePlatformLevelApiGetTransferLimitsInput {
	r.transferType = &transferType
	return r
}

// The status of the transfer limit. Possible values:    * **active**: the limit is currently active. * **inactive**: the limit is currently inactive. * **pendingSCA**: the limit is pending until your user performs SCA. * **scheduled**: the limit is scheduled to become active at a future date.
func (r TransferLimitsBalancePlatformLevelApiGetTransferLimitsInput) Status(status LimitStatus) TransferLimitsBalancePlatformLevelApiGetTransferLimitsInput {
	r.status = &status
	return r
}


/*
Prepare a request for GetTransferLimits
@param id The unique identifier of the balance platform.
@return TransferLimitsBalancePlatformLevelApiGetTransferLimitsInput
*/
func (a *TransferLimitsBalancePlatformLevelApi) GetTransferLimitsInput(id string) TransferLimitsBalancePlatformLevelApiGetTransferLimitsInput {
	return TransferLimitsBalancePlatformLevelApiGetTransferLimitsInput{
		id: id,
	}
}

/*
GetTransferLimits Filter and view the transfer limits

Filter and view the transfer limits configured for your balance platform using the balance platform's unique `id` and the available query parameters.


@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
@param r TransferLimitsBalancePlatformLevelApiGetTransferLimitsInput - Request parameters, see GetTransferLimitsInput
@return TransferLimitListResponse, *http.Response, error
*/
func (a *TransferLimitsBalancePlatformLevelApi) GetTransferLimits(ctx context.Context, r TransferLimitsBalancePlatformLevelApiGetTransferLimitsInput) (TransferLimitListResponse, *http.Response, error) {
    res := &TransferLimitListResponse{}
	path := "/balancePlatforms/{id}/transferLimits"
    path = strings.Replace(path, "{"+"id"+"}", url.PathEscape(common.ParameterValueToString(r.id, "id")), -1)
    queryParams := url.Values{}
    headerParams := make(map[string]string)
    if r.scope != nil {
        common.ParameterAddToQuery(queryParams, "scope", r.scope, "")
    }
    if r.transferType != nil {
        common.ParameterAddToQuery(queryParams, "transferType", r.transferType, "")
    }
    if r.status != nil {
        common.ParameterAddToQuery(queryParams, "status", r.status, "")
    }
    httpRes, err := common.SendAPIRequest(
        ctx,
        a.Client,
        nil,
        res,
        http.MethodGet,
        a.BasePath()+path,
        queryParams,
        headerParams,
    )

    if httpRes == nil {
        return *res, httpRes, err
    }

    var serviceError common.RestServiceError
                        if httpRes.StatusCode == 404 {
                            body, _ := ioutil.ReadAll(httpRes.Body)
                            decodeError := json.Unmarshal([]byte(body), &serviceError)
                            if decodeError != nil {
                                return *res, httpRes, decodeError
                            }
                            return *res, httpRes, serviceError
                        }
                        if httpRes.StatusCode == 422 {
                            body, _ := ioutil.ReadAll(httpRes.Body)
                            decodeError := json.Unmarshal([]byte(body), &serviceError)
                            if decodeError != nil {
                                return *res, httpRes, decodeError
                            }
                            return *res, httpRes, serviceError
                        }

    return *res, httpRes, err
}

