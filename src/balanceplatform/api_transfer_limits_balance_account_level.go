/*
Configuration API

API version: 2
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package balanceplatform

import (
	"context"
	"encoding/json"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"

	"github.com/adyen/adyen-go-api-library/v21/src/common"
)

// TransferLimitsBalanceAccountLevelApi service
type TransferLimitsBalanceAccountLevelApi common.Service

// All parameters accepted by TransferLimitsBalanceAccountLevelApi.ApprovePendingTransferLimits
type TransferLimitsBalanceAccountLevelApiApprovePendingTransferLimitsInput struct {
	id                          string
	approveTransferLimitRequest *ApproveTransferLimitRequest
	wWWAuthenticate             *string
}

func (r TransferLimitsBalanceAccountLevelApiApprovePendingTransferLimitsInput) ApproveTransferLimitRequest(approveTransferLimitRequest ApproveTransferLimitRequest) TransferLimitsBalanceAccountLevelApiApprovePendingTransferLimitsInput {
	r.approveTransferLimitRequest = &approveTransferLimitRequest
	return r
}

// Header for authenticating using SCA.
func (r TransferLimitsBalanceAccountLevelApiApprovePendingTransferLimitsInput) WWWAuthenticate(wWWAuthenticate string) TransferLimitsBalanceAccountLevelApiApprovePendingTransferLimitsInput {
	r.wWWAuthenticate = &wWWAuthenticate
	return r
}

/*
Prepare a request for ApprovePendingTransferLimits
@param id The unique identifier of the balance account.
@return TransferLimitsBalanceAccountLevelApiApprovePendingTransferLimitsInput
*/
func (a *TransferLimitsBalanceAccountLevelApi) ApprovePendingTransferLimitsInput(id string) TransferLimitsBalanceAccountLevelApiApprovePendingTransferLimitsInput {
	return TransferLimitsBalanceAccountLevelApiApprovePendingTransferLimitsInput{
		id: id,
	}
}

/*
ApprovePendingTransferLimits Approve pending transfer limits

Approve transfer limits that are pending SCA authentication.

@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
@param r TransferLimitsBalanceAccountLevelApiApprovePendingTransferLimitsInput - Request parameters, see ApprovePendingTransferLimitsInput
@return *http.Response, error
*/
func (a *TransferLimitsBalanceAccountLevelApi) ApprovePendingTransferLimits(ctx context.Context, r TransferLimitsBalanceAccountLevelApiApprovePendingTransferLimitsInput) (*http.Response, error) {
	var res interface{}
	path := "/balanceAccounts/{id}/transferLimits/approve"
	path = strings.Replace(path, "{"+"id"+"}", url.PathEscape(common.ParameterValueToString(r.id, "id")), -1)
	queryParams := url.Values{}
	headerParams := make(map[string]string)
	if r.wWWAuthenticate != nil {
		common.ParameterAddToHeaderOrQuery(headerParams, "WWW-Authenticate", r.wWWAuthenticate, "")
	}
	httpRes, err := common.SendAPIRequest(
		ctx,
		a.Client,
		r.approveTransferLimitRequest,
		res,
		http.MethodPost,
		a.BasePath()+path,
		queryParams,
		headerParams,
	)

	if httpRes == nil {
		return httpRes, err
	}

	var serviceError common.RestServiceError
	if httpRes.StatusCode == 401 {
		body, _ := ioutil.ReadAll(httpRes.Body)
		decodeError := json.Unmarshal([]byte(body), &serviceError)
		if decodeError != nil {
			return httpRes, decodeError
		}
		return httpRes, serviceError
	}
	if httpRes.StatusCode == 404 {
		body, _ := ioutil.ReadAll(httpRes.Body)
		decodeError := json.Unmarshal([]byte(body), &serviceError)
		if decodeError != nil {
			return httpRes, decodeError
		}
		return httpRes, serviceError
	}
	if httpRes.StatusCode == 422 {
		body, _ := ioutil.ReadAll(httpRes.Body)
		decodeError := json.Unmarshal([]byte(body), &serviceError)
		if decodeError != nil {
			return httpRes, decodeError
		}
		return httpRes, serviceError
	}

	return httpRes, err
}

// All parameters accepted by TransferLimitsBalanceAccountLevelApi.CreateTransferLimit
type TransferLimitsBalanceAccountLevelApiCreateTransferLimitInput struct {
	id                         string
	createTransferLimitRequest *CreateTransferLimitRequest
	wWWAuthenticate            *string
}

func (r TransferLimitsBalanceAccountLevelApiCreateTransferLimitInput) CreateTransferLimitRequest(createTransferLimitRequest CreateTransferLimitRequest) TransferLimitsBalanceAccountLevelApiCreateTransferLimitInput {
	r.createTransferLimitRequest = &createTransferLimitRequest
	return r
}

// Header for authenticating through SCA
func (r TransferLimitsBalanceAccountLevelApiCreateTransferLimitInput) WWWAuthenticate(wWWAuthenticate string) TransferLimitsBalanceAccountLevelApiCreateTransferLimitInput {
	r.wWWAuthenticate = &wWWAuthenticate
	return r
}

/*
Prepare a request for CreateTransferLimit
@param id The unique identifier of the balance account.
@return TransferLimitsBalanceAccountLevelApiCreateTransferLimitInput
*/
func (a *TransferLimitsBalanceAccountLevelApi) CreateTransferLimitInput(id string) TransferLimitsBalanceAccountLevelApiCreateTransferLimitInput {
	return TransferLimitsBalanceAccountLevelApiCreateTransferLimitInput{
		id: id,
	}
}

/*
CreateTransferLimit Create a transfer limit

Create a transfer limit for your balance account using the unique `id` of your balance account.

@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
@param r TransferLimitsBalanceAccountLevelApiCreateTransferLimitInput - Request parameters, see CreateTransferLimitInput
@return TransferLimit, *http.Response, error
*/
func (a *TransferLimitsBalanceAccountLevelApi) CreateTransferLimit(ctx context.Context, r TransferLimitsBalanceAccountLevelApiCreateTransferLimitInput) (TransferLimit, *http.Response, error) {
	res := &TransferLimit{}
	path := "/balanceAccounts/{id}/transferLimits"
	path = strings.Replace(path, "{"+"id"+"}", url.PathEscape(common.ParameterValueToString(r.id, "id")), -1)
	queryParams := url.Values{}
	headerParams := make(map[string]string)
	if r.wWWAuthenticate != nil {
		common.ParameterAddToHeaderOrQuery(headerParams, "WWW-Authenticate", r.wWWAuthenticate, "")
	}
	httpRes, err := common.SendAPIRequest(
		ctx,
		a.Client,
		r.createTransferLimitRequest,
		res,
		http.MethodPost,
		a.BasePath()+path,
		queryParams,
		headerParams,
	)

	if httpRes == nil {
		return *res, httpRes, err
	}

	var serviceError common.RestServiceError
	if httpRes.StatusCode == 400 {
		body, _ := ioutil.ReadAll(httpRes.Body)
		decodeError := json.Unmarshal([]byte(body), &serviceError)
		if decodeError != nil {
			return *res, httpRes, decodeError
		}
		return *res, httpRes, serviceError
	}
	if httpRes.StatusCode == 401 {
		body, _ := ioutil.ReadAll(httpRes.Body)
		decodeError := json.Unmarshal([]byte(body), &serviceError)
		if decodeError != nil {
			return *res, httpRes, decodeError
		}
		return *res, httpRes, serviceError
	}
	if httpRes.StatusCode == 422 {
		body, _ := ioutil.ReadAll(httpRes.Body)
		decodeError := json.Unmarshal([]byte(body), &serviceError)
		if decodeError != nil {
			return *res, httpRes, decodeError
		}
		return *res, httpRes, serviceError
	}

	return *res, httpRes, err
}

// All parameters accepted by TransferLimitsBalanceAccountLevelApi.DeletePendingTransferLimit
type TransferLimitsBalanceAccountLevelApiDeletePendingTransferLimitInput struct {
	id              string
	transferLimitId string
}

/*
Prepare a request for DeletePendingTransferLimit
@param id The unique identifier of the balance account.@param transferLimitId The unique identifier of the transfer limit.
@return TransferLimitsBalanceAccountLevelApiDeletePendingTransferLimitInput
*/
func (a *TransferLimitsBalanceAccountLevelApi) DeletePendingTransferLimitInput(id string, transferLimitId string) TransferLimitsBalanceAccountLevelApiDeletePendingTransferLimitInput {
	return TransferLimitsBalanceAccountLevelApiDeletePendingTransferLimitInput{
		id:              id,
		transferLimitId: transferLimitId,
	}
}

/*
DeletePendingTransferLimit Delete a scheduled or pending transfer limit

Delete a scheduled or pending transfer limit using its unique `transferLimitId`. You cannot delete an active limit.

@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
@param r TransferLimitsBalanceAccountLevelApiDeletePendingTransferLimitInput - Request parameters, see DeletePendingTransferLimitInput
@return *http.Response, error
*/
func (a *TransferLimitsBalanceAccountLevelApi) DeletePendingTransferLimit(ctx context.Context, r TransferLimitsBalanceAccountLevelApiDeletePendingTransferLimitInput) (*http.Response, error) {
	var res interface{}
	path := "/balanceAccounts/{id}/transferLimits/{transferLimitId}"
	path = strings.Replace(path, "{"+"id"+"}", url.PathEscape(common.ParameterValueToString(r.id, "id")), -1)
	path = strings.Replace(path, "{"+"transferLimitId"+"}", url.PathEscape(common.ParameterValueToString(r.transferLimitId, "transferLimitId")), -1)
	queryParams := url.Values{}
	headerParams := make(map[string]string)
	httpRes, err := common.SendAPIRequest(
		ctx,
		a.Client,
		nil,
		res,
		http.MethodDelete,
		a.BasePath()+path,
		queryParams,
		headerParams,
	)

	if httpRes == nil {
		return httpRes, err
	}

	var serviceError common.RestServiceError
	if httpRes.StatusCode == 404 {
		body, _ := ioutil.ReadAll(httpRes.Body)
		decodeError := json.Unmarshal([]byte(body), &serviceError)
		if decodeError != nil {
			return httpRes, decodeError
		}
		return httpRes, serviceError
	}
	if httpRes.StatusCode == 422 {
		body, _ := ioutil.ReadAll(httpRes.Body)
		decodeError := json.Unmarshal([]byte(body), &serviceError)
		if decodeError != nil {
			return httpRes, decodeError
		}
		return httpRes, serviceError
	}

	return httpRes, err
}

// All parameters accepted by TransferLimitsBalanceAccountLevelApi.GetCurrentTransferLimits
type TransferLimitsBalanceAccountLevelApiGetCurrentTransferLimitsInput struct {
	id           string
	scope        *Scope
	transferType *TransferType
}

// The scope to which the transfer limit applies. Possible values: * **perTransaction**: you set a maximum amount for each transfer made from the balance account or balance platform. * **perDay**: you set a maximum total amount for all transfers made from the balance account or balance platform in a day.
func (r TransferLimitsBalanceAccountLevelApiGetCurrentTransferLimitsInput) Scope(scope Scope) TransferLimitsBalanceAccountLevelApiGetCurrentTransferLimitsInput {
	r.scope = &scope
	return r
}

// The type of transfer to which the limit applies. Possible values: * **instant**: the limit applies to transfers with an **instant** priority. * **all**: the limit applies to all transfers, regardless of priority.
func (r TransferLimitsBalanceAccountLevelApiGetCurrentTransferLimitsInput) TransferType(transferType TransferType) TransferLimitsBalanceAccountLevelApiGetCurrentTransferLimitsInput {
	r.transferType = &transferType
	return r
}

/*
Prepare a request for GetCurrentTransferLimits
@param id The unique identifier of the balance account.
@return TransferLimitsBalanceAccountLevelApiGetCurrentTransferLimitsInput
*/
func (a *TransferLimitsBalanceAccountLevelApi) GetCurrentTransferLimitsInput(id string) TransferLimitsBalanceAccountLevelApiGetCurrentTransferLimitsInput {
	return TransferLimitsBalanceAccountLevelApiGetCurrentTransferLimitsInput{
		id: id,
	}
}

/*
GetCurrentTransferLimits Get all current transfer limits

Get all transfer limits that currently apply to a balance account using the unique `id` of the balance account.

@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
@param r TransferLimitsBalanceAccountLevelApiGetCurrentTransferLimitsInput - Request parameters, see GetCurrentTransferLimitsInput
@return TransferLimitListResponse, *http.Response, error
*/
func (a *TransferLimitsBalanceAccountLevelApi) GetCurrentTransferLimits(ctx context.Context, r TransferLimitsBalanceAccountLevelApiGetCurrentTransferLimitsInput) (TransferLimitListResponse, *http.Response, error) {
	res := &TransferLimitListResponse{}
	path := "/balanceAccounts/{id}/transferLimits/current"
	path = strings.Replace(path, "{"+"id"+"}", url.PathEscape(common.ParameterValueToString(r.id, "id")), -1)
	queryParams := url.Values{}
	headerParams := make(map[string]string)
	if r.scope != nil {
		common.ParameterAddToQuery(queryParams, "scope", r.scope, "")
	}
	if r.transferType != nil {
		common.ParameterAddToQuery(queryParams, "transferType", r.transferType, "")
	}
	httpRes, err := common.SendAPIRequest(
		ctx,
		a.Client,
		nil,
		res,
		http.MethodGet,
		a.BasePath()+path,
		queryParams,
		headerParams,
	)

	if httpRes == nil {
		return *res, httpRes, err
	}

	var serviceError common.RestServiceError
	if httpRes.StatusCode == 404 {
		body, _ := ioutil.ReadAll(httpRes.Body)
		decodeError := json.Unmarshal([]byte(body), &serviceError)
		if decodeError != nil {
			return *res, httpRes, decodeError
		}
		return *res, httpRes, serviceError
	}
	if httpRes.StatusCode == 422 {
		body, _ := ioutil.ReadAll(httpRes.Body)
		decodeError := json.Unmarshal([]byte(body), &serviceError)
		if decodeError != nil {
			return *res, httpRes, decodeError
		}
		return *res, httpRes, serviceError
	}

	return *res, httpRes, err
}

// All parameters accepted by TransferLimitsBalanceAccountLevelApi.GetSpecificTransferLimit
type TransferLimitsBalanceAccountLevelApiGetSpecificTransferLimitInput struct {
	id              string
	transferLimitId string
}

/*
Prepare a request for GetSpecificTransferLimit
@param id The unique identifier of the balance account.@param transferLimitId The unique identifier of the transfer limit.
@return TransferLimitsBalanceAccountLevelApiGetSpecificTransferLimitInput
*/
func (a *TransferLimitsBalanceAccountLevelApi) GetSpecificTransferLimitInput(id string, transferLimitId string) TransferLimitsBalanceAccountLevelApiGetSpecificTransferLimitInput {
	return TransferLimitsBalanceAccountLevelApiGetSpecificTransferLimitInput{
		id:              id,
		transferLimitId: transferLimitId,
	}
}

/*
GetSpecificTransferLimit Get the details of a transfer limit

Get the details of a transfer limit using its unique `transferLimitId`.

@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
@param r TransferLimitsBalanceAccountLevelApiGetSpecificTransferLimitInput - Request parameters, see GetSpecificTransferLimitInput
@return TransferLimit, *http.Response, error
*/
func (a *TransferLimitsBalanceAccountLevelApi) GetSpecificTransferLimit(ctx context.Context, r TransferLimitsBalanceAccountLevelApiGetSpecificTransferLimitInput) (TransferLimit, *http.Response, error) {
	res := &TransferLimit{}
	path := "/balanceAccounts/{id}/transferLimits/{transferLimitId}"
	path = strings.Replace(path, "{"+"id"+"}", url.PathEscape(common.ParameterValueToString(r.id, "id")), -1)
	path = strings.Replace(path, "{"+"transferLimitId"+"}", url.PathEscape(common.ParameterValueToString(r.transferLimitId, "transferLimitId")), -1)
	queryParams := url.Values{}
	headerParams := make(map[string]string)
	httpRes, err := common.SendAPIRequest(
		ctx,
		a.Client,
		nil,
		res,
		http.MethodGet,
		a.BasePath()+path,
		queryParams,
		headerParams,
	)

	if httpRes == nil {
		return *res, httpRes, err
	}

	var serviceError common.RestServiceError
	if httpRes.StatusCode == 404 {
		body, _ := ioutil.ReadAll(httpRes.Body)
		decodeError := json.Unmarshal([]byte(body), &serviceError)
		if decodeError != nil {
			return *res, httpRes, decodeError
		}
		return *res, httpRes, serviceError
	}
	if httpRes.StatusCode == 422 {
		body, _ := ioutil.ReadAll(httpRes.Body)
		decodeError := json.Unmarshal([]byte(body), &serviceError)
		if decodeError != nil {
			return *res, httpRes, decodeError
		}
		return *res, httpRes, serviceError
	}

	return *res, httpRes, err
}

// All parameters accepted by TransferLimitsBalanceAccountLevelApi.GetTransferLimits
type TransferLimitsBalanceAccountLevelApiGetTransferLimitsInput struct {
	id           string
	scope        *Scope
	transferType *TransferType
	status       *LimitStatus
}

// The scope to which the transfer limit applies. Possible values: * **perTransaction**: you set a maximum amount for each transfer made from the balance account or balance platform. * **perDay**: you set a maximum total amount for all transfers made from the balance account or balance platform in a day.
func (r TransferLimitsBalanceAccountLevelApiGetTransferLimitsInput) Scope(scope Scope) TransferLimitsBalanceAccountLevelApiGetTransferLimitsInput {
	r.scope = &scope
	return r
}

// The type of transfer to which the limit applies. Possible values: * **instant**: the limit applies to transfers with an **instant** priority. * **all**: the limit applies to all transfers, regardless of priority.
func (r TransferLimitsBalanceAccountLevelApiGetTransferLimitsInput) TransferType(transferType TransferType) TransferLimitsBalanceAccountLevelApiGetTransferLimitsInput {
	r.transferType = &transferType
	return r
}

// The status of the transfer limit. Possible values:    * **active**: the limit is currently active. * **inactive**: the limit is currently inactive. * **pendingSCA**: the limit is pending until your user performs SCA. * **scheduled**: the limit is scheduled to become active at a future date.
func (r TransferLimitsBalanceAccountLevelApiGetTransferLimitsInput) Status(status LimitStatus) TransferLimitsBalanceAccountLevelApiGetTransferLimitsInput {
	r.status = &status
	return r
}

/*
Prepare a request for GetTransferLimits
@param id The unique identifier of the balance account.
@return TransferLimitsBalanceAccountLevelApiGetTransferLimitsInput
*/
func (a *TransferLimitsBalanceAccountLevelApi) GetTransferLimitsInput(id string) TransferLimitsBalanceAccountLevelApiGetTransferLimitsInput {
	return TransferLimitsBalanceAccountLevelApiGetTransferLimitsInput{
		id: id,
	}
}

/*
GetTransferLimits Filter and view the transfer limits

Filter and view the transfer limits configured for a balance account using the balance account's unique `id` and the available query parameters.

@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
@param r TransferLimitsBalanceAccountLevelApiGetTransferLimitsInput - Request parameters, see GetTransferLimitsInput
@return TransferLimitListResponse, *http.Response, error
*/
func (a *TransferLimitsBalanceAccountLevelApi) GetTransferLimits(ctx context.Context, r TransferLimitsBalanceAccountLevelApiGetTransferLimitsInput) (TransferLimitListResponse, *http.Response, error) {
	res := &TransferLimitListResponse{}
	path := "/balanceAccounts/{id}/transferLimits"
	path = strings.Replace(path, "{"+"id"+"}", url.PathEscape(common.ParameterValueToString(r.id, "id")), -1)
	queryParams := url.Values{}
	headerParams := make(map[string]string)
	if r.scope != nil {
		common.ParameterAddToQuery(queryParams, "scope", r.scope, "")
	}
	if r.transferType != nil {
		common.ParameterAddToQuery(queryParams, "transferType", r.transferType, "")
	}
	if r.status != nil {
		common.ParameterAddToQuery(queryParams, "status", r.status, "")
	}
	httpRes, err := common.SendAPIRequest(
		ctx,
		a.Client,
		nil,
		res,
		http.MethodGet,
		a.BasePath()+path,
		queryParams,
		headerParams,
	)

	if httpRes == nil {
		return *res, httpRes, err
	}

	var serviceError common.RestServiceError
	if httpRes.StatusCode == 404 {
		body, _ := ioutil.ReadAll(httpRes.Body)
		decodeError := json.Unmarshal([]byte(body), &serviceError)
		if decodeError != nil {
			return *res, httpRes, decodeError
		}
		return *res, httpRes, serviceError
	}
	if httpRes.StatusCode == 422 {
		body, _ := ioutil.ReadAll(httpRes.Body)
		decodeError := json.Unmarshal([]byte(body), &serviceError)
		if decodeError != nil {
			return *res, httpRes, decodeError
		}
		return *res, httpRes, serviceError
	}

	return *res, httpRes, err
}
